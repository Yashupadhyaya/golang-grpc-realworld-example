// ********RoostGPT********
/*
Test generated by RoostGPT for test go-imports-test using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=CreateComment_c9eeba8015
ROOST_METHOD_SIG_HASH=CreateComment_9348ec6f77

FUNCTION_DEF=func (h *Handler) CreateComment(ctx context.Context, req *pb.CreateCommentRequest) (*pb.CommentResponse, error) // CreateComment create a comment for an article

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: golang-grpc-realworld-example/handler/comment_test.go
Test Cases:
    [TestCreateComment
    TestDeleteComment
    TestGetComments]

Based on the provided function and context, here are some test scenarios for the `CreateComment` function:

```
Scenario 1: Successful Comment Creation

Details:
  Description: Test the successful creation of a comment by an authenticated user on an existing article.
Execution:
  Arrange:
    - Create a test user and authenticate them
    - Create a test article
    - Prepare a valid CreateCommentRequest
  Act:
    - Call CreateComment with the authenticated context and valid request
  Assert:
    - Verify that no error is returned
    - Check that the returned CommentResponse contains the expected data
Validation:
  This test ensures that the basic flow of creating a comment works as expected, including proper authentication, article retrieval, and comment creation.

Scenario 2: Unauthenticated User Attempt

Details:
  Description: Verify that an unauthenticated user cannot create a comment.
Execution:
  Arrange:
    - Prepare a valid CreateCommentRequest
    - Use a context without authentication
  Act:
    - Call CreateComment with the unauthenticated context
  Assert:
    - Expect an error with Unauthenticated status code
Validation:
  This test is crucial to ensure that the authentication check is working correctly, preventing unauthorized comment creation.

Scenario 3: Invalid Article ID

Details:
  Description: Test the behavior when an invalid article ID (slug) is provided.
Execution:
  Arrange:
    - Create and authenticate a test user
    - Prepare a CreateCommentRequest with an invalid slug (e.g., "invalid-slug")
  Act:
    - Call CreateComment with the authenticated context and invalid request
  Assert:
    - Expect an error with InvalidArgument status code
Validation:
  This test ensures that the function properly validates the article ID and handles conversion errors appropriately.

Scenario 4: Non-existent Article

Details:
  Description: Verify the behavior when attempting to comment on a non-existent article.
Execution:
  Arrange:
    - Create and authenticate a test user
    - Prepare a CreateCommentRequest with a non-existent article ID
  Act:
    - Call CreateComment with the authenticated context and request
  Assert:
    - Expect an error with InvalidArgument status code
Validation:
  This test checks that the function correctly handles cases where the specified article does not exist in the database.

Scenario 5: Invalid Comment Data

Details:
  Description: Test the function's response to invalid comment data (e.g., empty body).
Execution:
  Arrange:
    - Create and authenticate a test user
    - Create a test article
    - Prepare a CreateCommentRequest with invalid comment data (e.g., empty body)
  Act:
    - Call CreateComment with the authenticated context and invalid request
  Assert:
    - Expect an error with InvalidArgument status code
Validation:
  This scenario ensures that the comment validation logic is working correctly, preventing the creation of invalid comments.

Scenario 6: Database Error on Comment Creation

Details:
  Description: Verify the function's behavior when a database error occurs during comment creation.
Execution:
  Arrange:
    - Create and authenticate a test user
    - Create a test article
    - Prepare a valid CreateCommentRequest
    - Mock the ArticleStore to simulate a database error on CreateComment
  Act:
    - Call CreateComment with the authenticated context and valid request
  Assert:
    - Expect an error with Aborted status code
Validation:
  This test ensures that the function handles database errors gracefully and returns an appropriate error to the client.

Scenario 7: Successful Comment Creation with Maximum Length Body

Details:
  Description: Test creating a comment with the maximum allowed body length.
Execution:
  Arrange:
    - Create and authenticate a test user
    - Create a test article
    - Prepare a CreateCommentRequest with a body at the maximum allowed length
  Act:
    - Call CreateComment with the authenticated context and request
  Assert:
    - Verify that no error is returned
    - Check that the returned CommentResponse contains the full comment body
Validation:
  This test ensures that the function can handle comments at the maximum allowed length without truncation or errors.
```

These scenarios cover a range of normal operations, edge cases, and error handling situations for the `CreateComment` function. They test authentication, input validation, database interactions, and various potential error conditions.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"fmt"
	"testing"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

type mockArticleStore struct {
	mock.Mock
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) CreateComment(comment *model.Comment) error {
	args := m.Called(comment)
	return args.Error(0)
}

func TestHandlerCreateComment(t *testing.T) {
	logger := zerolog.New(zerolog.NewTestWriter(t))

	tests := []struct {
		name              string
		setupAuth         func(context.Context) context.Context
		setupUserStore    func(*mockUserStore)
		setupArticleStore func(*mockArticleStore)
		req               *pb.CreateCommentRequest
		wantErr           bool
		wantErrCode       codes.Code
	}{
		{
			name: "Successful Comment Creation",
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.On("GetByID", uint(1)).Return(&model.User{Model: model.Model{ID: 1}, Username: "testuser"}, nil)
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.On("GetByID", uint(1)).Return(&model.Article{Model: model.Model{ID: 1}, Title: "Test Article"}, nil)
				as.On("CreateComment", mock.AnythingOfType("*model.Comment")).Return(nil)
			},
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "Test comment",
				},
			},
			wantErr: false,
		},
		{
			name: "Unauthenticated User",
			setupAuth: func(ctx context.Context) context.Context {
				return ctx
			},
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "Test comment",
				},
			},
			wantErr:     true,
			wantErrCode: codes.Unauthenticated,
		},
		{
			name: "Invalid Article ID",
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.On("GetByID", uint(1)).Return(&model.User{Model: model.Model{ID: 1}, Username: "testuser"}, nil)
			},
			req: &pb.CreateCommentRequest{
				Slug: "invalid",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "Test comment",
				},
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Non-existent Article",
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.On("GetByID", uint(1)).Return(&model.User{Model: model.Model{ID: 1}, Username: "testuser"}, nil)
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.On("GetByID", uint(999)).Return((*model.Article)(nil), fmt.Errorf("article not found"))
			},
			req: &pb.CreateCommentRequest{
				Slug: "999",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "Test comment",
				},
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Invalid Comment Data",
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.On("GetByID", uint(1)).Return(&model.User{Model: model.Model{ID: 1}, Username: "testuser"}, nil)
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.On("GetByID", uint(1)).Return(&model.Article{Model: model.Model{ID: 1}, Title: "Test Article"}, nil)
			},
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "", // Empty body, should fail validation
				},
			},
			wantErr:     true,
			wantErrCode: codes.InvalidArgument,
		},
		{
			name: "Database Error on Comment Creation",
			setupAuth: func(ctx context.Context) context.Context {
				return auth.NewContext(ctx, uint(1))
			},
			setupUserStore: func(us *mockUserStore) {
				us.On("GetByID", uint(1)).Return(&model.User{Model: model.Model{ID: 1}, Username: "testuser"}, nil)
			},
			setupArticleStore: func(as *mockArticleStore) {
				as.On("GetByID", uint(1)).Return(&model.Article{Model: model.Model{ID: 1}, Title: "Test Article"}, nil)
				as.On("CreateComment", mock.AnythingOfType("*model.Comment")).Return(fmt.Errorf("database error"))
			},
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "Test comment",
				},
			},
			wantErr:     true,
			wantErrCode: codes.Aborted,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			if tt.setupAuth != nil {
				ctx = tt.setupAuth(ctx)
			}

			mockUS := new(mockUserStore)
			mockAS := new(mockArticleStore)

			if tt.setupUserStore != nil {
				tt.setupUserStore(mockUS)
			}
			if tt.setupArticleStore != nil {
				tt.setupArticleStore(mockAS)
			}

			h := &Handler{
				logger: &logger,
				us:     mockUS,
				as:     mockAS,
			}

			resp, err := h.CreateComment(ctx, tt.req)

			if tt.wantErr {
				assert.Error(t, err)
				st, ok := status.FromError(err)
				assert.True(t, ok)
				assert.Equal(t, tt.wantErrCode, st.Code())
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, resp)
				assert.NotNil(t, resp.Comment)
				assert.NotEmpty(t, resp.Comment.Id)
				assert.Equal(t, tt.req.Comment.Body, resp.Comment.Body)
				assert.NotEmpty(t, resp.Comment.CreatedAt)
				assert.NotEmpty(t, resp.Comment.UpdatedAt)
				assert.NotNil(t, resp.Comment.Author)
			}

			mockUS.AssertExpectations(t)
			mockAS.AssertExpectations(t)
		})
	}
}
