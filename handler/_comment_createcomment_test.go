// ********RoostGPT********
/*
Test generated by RoostGPT for test test-golang-mock using AI Type Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=CreateComment_c4ccd62dc5
ROOST_METHOD_SIG_HASH=CreateComment_19a3ee5a3b

FUNCTION_DEF=func (h *Handler) CreateComment(ctx context.Context, req *pb.CreateCommentRequest) (*pb.CommentResponse, error)
Here are several test scenarios covering different aspects of the `CreateComment` function:

```
Scenario 1: Successfully create a comment

Details:
  Description: This test checks the successful creation of a comment when all inputs are valid and the user is authenticated.
Execution:
  Arrange: Set up a valid context with an authenticated user, a valid `CreateCommentRequest` with existing article slug, and mock responses for user and article retrieval.
  Act: Invoke `CreateComment` with the arranged context and request.
  Assert: Verify that the response contains the expected `CommentResponse` and no error is returned.
Validation:
  The assertion checks that the comment creation process completes without errors and returns the correct response, validating the main functionality of the method.

Scenario 2: User is unauthenticated

Details:
  Description: This test verifies that the function returns an unauthenticated error when the user is not authenticated.
Execution:
  Arrange: Set up a context without user authentication and prepare a valid `CreateCommentRequest`.
  Act: Invoke `CreateComment` with the arranged context and request.
  Assert: Check that the error returned is `codes.Unauthenticated`.
Validation:
  The assertion ensures that the function correctly identifies and handles unauthenticated access, which is crucial for security.

Scenario 3: User not found in the database

Details:
  Description: This test ensures the function returns a not found error when the user ID is not found in the database.
Execution:
  Arrange: Set up a context with a valid user ID, but mock the user store to return a not found error.
  Act: Invoke `CreateComment` with the arranged context and request.
  Assert: Verify that the error returned is `codes.NotFound`.
Validation:
  This test confirms that the function handles cases where the user does not exist, maintaining data integrity and consistency.

Scenario 4: Invalid article slug

Details:
  Description: This test checks the function's handling of an invalid article slug that cannot be converted to an integer.
Execution:
  Arrange: Set up a context with a valid user ID and a `CreateCommentRequest` with a non-integer slug.
  Act: Invoke `CreateComment` with the arranged context and request.
  Assert: Verify that the error returned is `codes.InvalidArgument`.
Validation:
  The test ensures that the function validates input data correctly, which is important for preventing errors and ensuring correct data processing.

Scenario 5: Article not found

Details:
  Description: This test verifies that the function returns an error when the article ID derived from the slug does not exist.
Execution:
  Arrange: Set up a context with a valid user ID and a `CreateCommentRequest` with a slug corresponding to a non-existent article.
  Act: Invoke `CreateComment` with the arranged context and request.
  Assert: Check that the error returned is `codes.InvalidArgument`.
Validation:
  This test ensures that the function correctly handles cases where the specified article does not exist, maintaining the correctness of associations.

Scenario 6: Comment validation failure

Details:
  Description: This test checks the function's response when comment validation fails.
Execution:
  Arrange: Set up a context with a valid user ID and a `CreateCommentRequest` with invalid comment data.
  Act: Invoke `CreateComment` with the arranged context and request.
  Assert: Verify that the error returned is `codes.InvalidArgument`.
Validation:
  The test confirms that the function properly validates comment data, which is crucial for data integrity and application robustness.

Scenario 7: Database error on comment creation

Details:
  Description: This test ensures that the function handles database errors during comment creation gracefully.
Execution:
  Arrange: Set up a context with valid data but mock the article store to return an error on comment creation.
  Act: Invoke `CreateComment` with the arranged context and request.
  Assert: Check that the error returned is `codes.Aborted`.
Validation:
  The test ensures that the function can handle unexpected errors during database operations, which is important for reliability and user feedback.
```

These scenarios cover a range of outcomes and edge cases, ensuring that the `CreateComment` function is robust and handles both expected and unexpected conditions appropriately.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"reflect"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/raahii/golang-grpc-realworld-example/auth"
	pb "github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/raahii/golang-grpc-realworld-example/store"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

func TestHandlerCreateComment(t *testing.T) {
	type testCase struct {
		name      string
		ctx       context.Context
		req       *pb.CreateCommentRequest
		mockSetup func(mock sqlmock.Sqlmock)
		expected  *pb.CommentResponse
		expectErr bool
		errorCode codes.Code
	}

	tests := []testCase{
		{
			name: "Successfully create a comment",
			ctx:  auth.WithUserID(context.Background(), 1),
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "This is a test comment",
				},
			},
			mockSetup: func(mock sqlmock.Sqlmock) {
				mock.ExpectQuery("^SELECT \\* FROM \"users\" WHERE \"users\".\"id\" = \\$1").
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id", "username"}).AddRow(1, "testuser"))

				mock.ExpectQuery("^SELECT \\* FROM \"articles\" WHERE \"articles\".\"id\" = \\$1").
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

				mock.ExpectBegin()
				mock.ExpectExec("^INSERT INTO \"comments\"").
					WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
			expected: &pb.CommentResponse{
				Comment: &pb.Comment{
					Body: "This is a test comment",
					Author: &pb.Profile{
						Username: "testuser",
					},
				},
			},
			expectErr: false,
		},
		{
			name: "User is unauthenticated",
			ctx:  context.Background(),
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "This is a test comment",
				},
			},
			mockSetup: func(mock sqlmock.Sqlmock) {},
			expected:  nil,
			expectErr: true,
			errorCode: codes.Unauthenticated,
		},
		{
			name: "User not found in the database",
			ctx:  auth.WithUserID(context.Background(), 1),
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "This is a test comment",
				},
			},
			mockSetup: func(mock sqlmock.Sqlmock) {
				mock.ExpectQuery("^SELECT \\* FROM \"users\" WHERE \"users\".\"id\" = \\$1").
					WithArgs(1).
					WillReturnError(status.Error(codes.NotFound, "user not found"))
			},
			expected:  nil,
			expectErr: true,
			errorCode: codes.NotFound,
		},
		{
			name: "Invalid article slug",
			ctx:  auth.WithUserID(context.Background(), 1),
			req: &pb.CreateCommentRequest{
				Slug: "invalid-slug",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "This is a test comment",
				},
			},
			mockSetup: func(mock sqlmock.Sqlmock) {},
			expected:  nil,
			expectErr: true,
			errorCode: codes.InvalidArgument,
		},
		{
			name: "Article not found",
			ctx:  auth.WithUserID(context.Background(), 1),
			req: &pb.CreateCommentRequest{
				Slug: "999",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "This is a test comment",
				},
			},
			mockSetup: func(mock sqlmock.Sqlmock) {
				mock.ExpectQuery("^SELECT \\* FROM \"articles\" WHERE \"articles\".\"id\" = \\$1").
					WithArgs(999).
					WillReturnError(status.Error(codes.InvalidArgument, "invalid article id"))
			},
			expected:  nil,
			expectErr: true,
			errorCode: codes.InvalidArgument,
		},
		{
			name: "Comment validation failure",
			ctx:  auth.WithUserID(context.Background(), 1),
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "",
				},
			},
			mockSetup: func(mock sqlmock.Sqlmock) {},
			expected:  nil,
			expectErr: true,
			errorCode: codes.InvalidArgument,
		},
		{
			name: "Database error on comment creation",
			ctx:  auth.WithUserID(context.Background(), 1),
			req: &pb.CreateCommentRequest{
				Slug: "1",
				Comment: &pb.CreateCommentRequest_Comment{
					Body: "This is a test comment",
				},
			},
			mockSetup: func(mock sqlmock.Sqlmock) {
				mock.ExpectQuery("^SELECT \\* FROM \"users\" WHERE \"users\".\"id\" = \\$1").
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id", "username"}).AddRow(1, "testuser"))

				mock.ExpectQuery("^SELECT \\* FROM \"articles\" WHERE \"articles\".\"id\" = \\$1").
					WithArgs(1).
					WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

				mock.ExpectBegin()
				mock.ExpectExec("^INSERT INTO \"comments\"").
					WillReturnError(status.Error(codes.Aborted, "failed to create comment."))
				mock.ExpectRollback()
			},
			expected:  nil,
			expectErr: true,
			errorCode: codes.Aborted,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			sqlDB, mock, err := sqlmock.New()
			if err != nil {
				t.Fatalf("failed to open sqlmock database: %s", err)
			}
			defer sqlDB.Close()

			gormDB, err := gorm.Open(postgres.New(postgres.Config{
				Conn: sqlDB,
			}), &gorm.Config{})
			if err != nil {
				t.Fatalf("failed to open gorm database: %s", err)
			}

			tt.mockSetup(mock)

			logger := zerolog.New(nil)
			userStore := &store.UserStore{DB: gormDB}
			articleStore := &store.ArticleStore{DB: gormDB}
			handler := &Handler{
				logger: &logger,
				us:     userStore,
				as:     articleStore,
			}

			resp, err := handler.CreateComment(tt.ctx, tt.req)

			if tt.expectErr {
				if err == nil {
					t.Fatalf("expected error but got nil")
				}
				st, ok := status.FromError(err)
				if !ok || st.Code() != tt.errorCode {
					t.Fatalf("expected error code %v, but got %v", tt.errorCode, st.Code())
				}
				t.Logf("received expected error: %v", err)
			} else {
				if err != nil {
					t.Fatalf("did not expect error but got %v", err)
				}
				if !reflect.DeepEqual(resp, tt.expected) {
					t.Fatalf("expected response %v, but got %v", tt.expected, resp)
				}
				t.Logf("received expected response: %v", resp)
			}

			if err := mock.ExpectationsWereMet(); err != nil {
				t.Fatalf("there were unfulfilled expectations: %s", err)
			}
		})
	}
}
