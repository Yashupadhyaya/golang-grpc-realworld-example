// ********RoostGPT********
/*
Test generated by RoostGPT for test go-imports-test using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=CreateComment_c9eeba8015
ROOST_METHOD_SIG_HASH=CreateComment_9348ec6f77

FUNCTION_DEF=func (h *Handler) CreateComment(ctx context.Context, req *pb.CreateCommentRequest) (*pb.CommentResponse, error) // CreateComment create a comment for an article

Existing Test Information:
These test cases are already implemented and not included for test generation scenario:
File: golang-grpc-realworld-example/handler/comment_test.go
Test Cases:
    [TestCreateComment
    TestDeleteComment
    TestGetComments]

Based on the provided function and context, here are some test scenarios for the CreateComment function:

```
Scenario 1: Successfully Create a Comment

Details:
  Description: This test verifies that a valid user can successfully create a comment on an existing article.
Execution:
  Arrange:
    - Create a test user and authenticate them
    - Create a test article
    - Prepare a valid CreateCommentRequest
  Act:
    - Call the CreateComment function with the authenticated context and valid request
  Assert:
    - Verify that no error is returned
    - Check that the returned CommentResponse contains the expected data
Validation:
  This test ensures the basic functionality of comment creation works as expected. It's crucial for the core feature of user interaction on articles.

Scenario 2: Attempt to Create Comment with Unauthenticated User

Details:
  Description: This test checks that an unauthenticated user cannot create a comment.
Execution:
  Arrange:
    - Prepare a valid CreateCommentRequest
    - Use a context without authentication
  Act:
    - Call the CreateComment function with the unauthenticated context
  Assert:
    - Verify that an error is returned
    - Check that the error code is Unauthenticated
Validation:
  This test is important to ensure that only authenticated users can create comments, maintaining the security of the application.

Scenario 3: Create Comment with Invalid Article ID

Details:
  Description: This test verifies that attempting to create a comment on a non-existent article fails appropriately.
Execution:
  Arrange:
    - Create and authenticate a test user
    - Prepare a CreateCommentRequest with an invalid article ID (slug)
  Act:
    - Call the CreateComment function with the authenticated context and invalid request
  Assert:
    - Verify that an error is returned
    - Check that the error code is InvalidArgument
Validation:
  This test ensures that the system properly handles attempts to comment on non-existent articles, maintaining data integrity.

Scenario 4: Create Comment with Empty Body

Details:
  Description: This test checks that attempting to create a comment with an empty body fails validation.
Execution:
  Arrange:
    - Create and authenticate a test user
    - Create a test article
    - Prepare a CreateCommentRequest with an empty comment body
  Act:
    - Call the CreateComment function with the authenticated context and invalid request
  Assert:
    - Verify that an error is returned
    - Check that the error code is InvalidArgument
Validation:
  This test ensures that the system enforces the requirement for non-empty comment bodies, maintaining the quality of user interactions.

Scenario 5: Create Comment with Very Long Body

Details:
  Description: This test verifies the system's handling of comments with very long bodies, potentially exceeding allowed limits.
Execution:
  Arrange:
    - Create and authenticate a test user
    - Create a test article
    - Prepare a CreateCommentRequest with an extremely long comment body
  Act:
    - Call the CreateComment function with the authenticated context and the long-body request
  Assert:
    - Verify the behavior (either successful creation or appropriate error handling)
Validation:
  This test checks the system's robustness in handling edge cases with input size, ensuring it either accepts valid long comments or gracefully handles oversized inputs.

Scenario 6: Concurrent Comment Creation

Details:
  Description: This test checks the system's ability to handle multiple concurrent comment creations.
Execution:
  Arrange:
    - Create multiple test users and authenticate them
    - Create a test article
    - Prepare multiple valid CreateCommentRequests
  Act:
    - Concurrently call the CreateComment function multiple times with different authenticated contexts
  Assert:
    - Verify that all comments are created successfully
    - Check that no errors occur due to race conditions
Validation:
  This test ensures that the comment creation process is thread-safe and can handle concurrent requests, which is crucial for a multi-user system.
```

These scenarios cover various aspects of the CreateComment function, including happy path, authentication, validation, error handling, and concurrency. They aim to ensure the robustness and correctness of the comment creation functionality.
*/

// ********RoostGPT********
package handler

import (
	"context"
	"strconv"
	"testing"
	"time"

	"github.com/raahii/golang-grpc-realworld-example/auth"
	"github.com/raahii/golang-grpc-realworld-example/model"
	"github.com/raahii/golang-grpc-realworld-example/proto"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) GetByID(id uint) (*model.User, error) {
	args := m.Called(id)
	return args.Get(0).(*model.User), args.Error(1)
}

type mockArticleStore struct {
	mock.Mock
}

func (m *mockArticleStore) GetByID(id uint) (*model.Article, error) {
	args := m.Called(id)
	return args.Get(0).(*model.Article), args.Error(1)
}

func (m *mockArticleStore) CreateComment(comment *model.Comment) error {
	args := m.Called(comment)
	return args.Error(0)
}

func TestHandlerCreateComment(t *testing.T) {
	logger := zerolog.New(zerolog.NewConsoleWriter())

	tests := []struct {
		name           string
		userID         uint
		req            *proto.CreateCommentRequest
		mockUser       *model.User
		mockArticle    *model.Article
		expectedError  error
		expectedResult *proto.CommentResponse
	}{
		{
			name:   "Successfully Create a Comment",
			userID: 1,
			req: &proto.CreateCommentRequest{
				Slug: "1",
				Comment: &proto.CreateCommentRequest_Comment{
					Body: "Test comment",
				},
			},
			mockUser: &model.User{
				Model:    model.Model{ID: 1},
				Username: "testuser",
			},
			mockArticle: &model.Article{
				Model: model.Model{ID: 1},
			},
			expectedError: nil,
			expectedResult: &proto.CommentResponse{
				Comment: &proto.Comment{
					Id:        "1",
					Body:      "Test comment",
					CreatedAt: time.Now().Format(time.RFC3339),
					UpdatedAt: time.Now().Format(time.RFC3339),
					Author: &proto.Profile{
						Username: "testuser",
					},
				},
			},
		},
		{
			name:          "Attempt to Create Comment with Unauthenticated User",
			userID:        0,
			req:           &proto.CreateCommentRequest{},
			expectedError: status.Error(codes.Unauthenticated, "unauthenticated"),
		},
		{
			name:   "Create Comment with Invalid Article ID",
			userID: 1,
			req: &proto.CreateCommentRequest{
				Slug: "invalid",
			},
			mockUser: &model.User{
				Model: model.Model{ID: 1},
			},
			expectedError: status.Error(codes.InvalidArgument, "invalid article id"),
		},
		{
			name:   "Create Comment with Empty Body",
			userID: 1,
			req: &proto.CreateCommentRequest{
				Slug: "1",
				Comment: &proto.CreateCommentRequest_Comment{
					Body: "",
				},
			},
			mockUser: &model.User{
				Model: model.Model{ID: 1},
			},
			mockArticle: &model.Article{
				Model: model.Model{ID: 1},
			},
			expectedError: status.Error(codes.InvalidArgument, "validation error: Body: cannot be blank."),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockUS := new(mockUserStore)
			mockAS := new(mockArticleStore)

			h := &Handler{
				logger: &logger,
				us:     mockUS,
				as:     mockAS,
			}

			ctx := context.Background()
			if tt.userID != 0 {
				ctx = context.WithValue(ctx, auth.UserIDKey, tt.userID)
			}

			if tt.mockUser != nil {
				mockUS.On("GetByID", tt.userID).Return(tt.mockUser, nil)
			}

			if tt.mockArticle != nil {
				articleID, _ := strconv.Atoi(tt.req.Slug)
				mockAS.On("GetByID", uint(articleID)).Return(tt.mockArticle, nil)
			}

			if tt.expectedResult != nil {
				mockAS.On("CreateComment", mock.AnythingOfType("*model.Comment")).Return(nil)
			}

			resp, err := h.CreateComment(ctx, tt.req)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, resp)
				assert.Equal(t, tt.expectedResult.Comment.Body, resp.Comment.Body)
				assert.Equal(t, tt.expectedResult.Comment.Author.Username, resp.Comment.Author.Username)
			}

			mockUS.AssertExpectations(t)
			mockAS.AssertExpectations(t)
		})
	}
}
